ErlangExports = erlang:module_info(exports),
Check = fun({F, A}) when is_atom(F), is_integer(A), A >= 0 ->
            erlang:is_builtin(erlang, F, A) orelse lists:member({F, A}, ErlangExports);
           ({M, F, A}) when is_atom(M), is_atom(F), is_integer(A), A >= 0 ->
            erlang:is_builtin(M, F, A) orelse (catch lists:member({F, A}, M:module_info(exports))) =:= true
        end,

BIFs = [{binary_to_integer, 1},
        {binary_to_float, 1},
        {integer_to_binary, 1},
        {integer_to_binary, 2},
        {float_to_binary, 1},
        {float_to_binary, 2},
        {float_to_list, 2},
        {get_keys, 0},
        {delete_element, 2},
        {insert_element, 3}],
Funs = [{binary_to_integer, 2},
        {erlang, timestamp, 0},
        {application, ensure_started, 1},
        {application, ensure_started, 2},
        {application, ensure_all_started, 1},
        {application, ensure_all_started, 2},
        {application, get_env, 3},
        {error_handler, raise_undef_exception, 3},
        {file, list_dir_all, 1},
        {file, read_link_all, 1},
        {inet, ntoa, 1},
        {inet, parse_address, 1},
        {inet, parse_ipv4_address, 1},
        {inet, parse_ipv4strict_address, 1},
        {inet, parse_ipv6_address, 1},
        {inet, parse_ipv6strict_address, 1},
        {inet, parse_strict_address, 1},
        {inet_parse, strict_address, 1},
        {edlin, current_chars, 1},
        {edlin, start, 2},
        {erl_compile, compile_cmdline, 0},
        {erl_scan, category, 1},
        {erl_scan, column, 1},
        {erl_scan, line, 1},
        {erl_scan, location, 1},
        {erl_scan, symbol, 1},
        {erl_scan, text, 1},
        {erl_scan, continuation_location, 1},
        {epp, parse_file, 2},
        {dict, is_empty, 1},
        {gen_event, system_get_state, 1},
        {gen_event, system_replace_state, 2},
        {gen_fsm, system_get_state, 1},
        {gen_fsm, system_replace_state, 2},
        {gen_server, system_get_state, 1},
        {gen_server, system_replace_state, 2},
        {lists, droplast, 1},
        {lists, filtermap, 2},
        {io_lib, deep_latin1_char_list, 1},
        {io_lib, latin1_char_list, 1},
        {io_lib, printable_latin1_list, 1},
        {io_lib, write_char_as_latin1, 1},
        {io_lib, write_latin1_char, 1},
        {io_lib, write_latin1_string, 1},
        {io_lib, write_latin1_string, 2},
        {io_lib, write_string_as_latin1, 1},
        {io_lib, write_string_as_latin1, 2},
        {orddict, is_empty, 1},
        {os, system_time, 1},
        {os, getenv, 2}],

lists:keystore(erl_opts, 1, CONFIG,
               {erl_opts,
                proplists:get_value(erl_opts, CONFIG, []) ++
                case erl_syntax:revert({tree, implicit_fun, {attr, 0, [], none},
                                        {remote, 0, {var, 0, 'M'},
                                         {tree, arity_qualifier, {attr, 0, [], none},
                                          {arity_qualifier, {var, 0, 'F'}, {integer, 0, 0}}}}}) of
                    {tree, implicit_fun, _, _} ->
                        io:fwrite(standard_error,
                                  "There is buggy internal revert_implicit_fun/1 in erl_syntax, using workaround~n", []),
                        [{d, buggy__revert_implicit_fun_1m}];
                    _ -> []
                end ++
                case erl_syntax:revert({tree, implicit_fun, {attr, 0, [], none},
                                        {tree, arity_qualifier, {attr, 0, [], none},
                                         {arity_qualifier, {tree, atom, {attr, 0, [], none}, test},
                                          {tree, integer, {attr, 0, [], none}, 0}}}}) of
                    {'fun', 0, {function, test, 0}} -> [];
                    _ ->
                        io:fwrite(standard_error,
                                  "There is buggy internal revert_implicit_fun/1 in erl_syntax, using workaround~n", []),
                        [{d, buggy__revert_implicit_fun_1a}]
                end ++
                lists:map(fun(E) ->
                              {d, list_to_atom(lists:flatten(io_lib:format("HAVE_~s__~s_~B",
                                                                           case E of
                                                                               {M, F, A} -> [M, F, A];
                                                                               {F, A} -> [erlang, F, A]
                                                                           end)))}
                          end, lists:filter(Check, BIFs ++ Funs))}).
